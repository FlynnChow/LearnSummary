#### 线程和进程的区别

1. 进程是程序的一次执行过程，是一个动态概念，是程序在执行过程中系统分配和管理资源的基本单位，每一个进程都有自己的地址空间
2. 线程是CPU调度和分派的基本单位，它可与同属一个进程的其他的线程共享进程所拥有的资源。
3. 线程是进程的一部分，一个线程只能属于一个进程，而一个进程可以有多个线程。
4. 每个进程都有独立的代码和数据空间，进程之间的切换会有较大的开销；线程可以看做轻量级的进程，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。
5. 系统在运行的时候会为每个进程分配不同的内存空间，线程所使用的资源来自其所属的进程。

#### 进程间的通信方式

1. 管道通信系统：

   **管道，就是内核里面的一串缓存**。从管道写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。

   管道分为匿名管道和命名管道。

   匿名管道是一个未命名的单向管道，它通过父进程和一个子进程之间传输数据它的通信范围是存在父子关系的进程，它的生命周期，随进程的结束而销毁。

   命名管道它可以在不相关的进程间也能相互通信。因为命令管道，提前创建了一个类型为管道的设备文件，在进程里只要使用这个设备文件，就可以相互通信。
* 管道是一个无格式的数据流，并且大小受限，它把一个进程的标准输出和另一个进程的标准输入连接在一起。写进程在管道的尾端写入数据，读进程在管道的头端读出数据。数据读出后将从管道中移走。
* 管道提供了简单的流控制机制。进程试图读空管道时，在有数据写入管道前，读进程将一直阻塞。进程往一个管道输入数据时，在其它进程从管道中取走数据前，写进程将一直阻塞。
* 管道通信效率低，不适合进程间频繁地交换数据

2. 信号量：信号量其实是一个整型的计数器，主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据。

3. 消息队列：消息队列是保存在内核中的消息链表。进程通过消息队列发送消息，只需把数据放在对应的消息队列后就可以正常返回。消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，如果进程从消息队列中读取了消息体，内核就会把这个消息体删除，消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在。

   缺点：1. 通信不及时，2. 附件也有大小限制 3. 消息队列通信，存在用户态与内核态的数据拷贝开销

4. 共享内存：共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了。

如果多个进程同时修改同一个共享内存，很有可能就冲突了

5. 套接字：Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。

   分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式

6. 信号：**对于异常情况下的工作模式，就需要用「信号」的方式来通知进程**

   信号是进程间通信机制中**唯一的异步通信机制**

   当我们不希望处理某些信号的时候，可以忽略除sigkill和sigstop的信号

**硬件来源**

- Ctrl+C 产生 `SIGINT` 信号，表示终止该进程；
- Ctrl+Z 产生 `SIGTSTP` 信号，表示停止该进程，但还未结束

**软件来源**

如：kill命令

#### 线程的同步机制

1.临界区：当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区对象的线程可以访问被保护的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程释放临界区为止。
2.事件：事件机制，允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。
3.互斥量：互斥对象和临界区对象非常相似，只是其允许在进程间使用（互斥量是可以命名的），而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。
4.信号量：信号量是用来限制可以使用某共享资源的线程数目。信号量对象保存了访问某个指定资源的线程的计数值。如果这个计数达到了零，则所有尝试范围资源的线程挂起，直到超时或计数值不为零为止。
#### 进程间调度方式

* FCFS(先来先服务算法)：非抢占，先请求CPU的进程先分配到CPU。
* SJF(最短作业优先调度算法)：非抢占，需要时间最短的进程先分配CPU
* 优先级调度算法：分抢占和非抢占，优先级高的先分配CPU
* 时间片轮转调度算法：为每个进程分配一个固定大小的时间片，进程用完时间片后就将CPU分配给其他进程。
* 多级队列调度算法：按照一定规则建立多个队列，每个队列的优先级和时间片不同。
* 多级反馈队列调度算法：在多级队列调度的基础上进程可以在不同的队列间移动，若一个进程在时间片内未完成任务会被移动到优先级更低的队列。

#### 分页和分段存储及区别

段式存储管理：把程序的地址空间分为若干段，以段为单位进行存储空间的管理。段内地址是连续的，段与段之间的地址可以是不连续的。
页式存储管理：将程序的逻辑地址划分为固定大小的页，物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分离。
不同：
1. 目的不同，分段是为了更好满足用户需求，分页是系统管理的需要。
2. 大小不同，段的长度不固定，页的大小固定由系统决定。
3. 地址空间不同，段向用户提供二维地址空间，页向用户提供一维地址空间。
4. 内存碎片不同，段的优点是没有内碎片，但是段段换入换出会产生外碎片，页没有外碎片，但是有内碎片。

#### 虚拟内存

每个进程拥有独立的地址空间，这个地址空间被分为大小相等的多个块，称为页，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。
作用：
1. 使逻辑上有比当前内存容量更大的空间
2. 内存可以保留多个进程

#### 页面置换算法

FIFO（先进先出算法）：选择最先进入内存的页面进行淘汰。
LRU（最近最少使用算法）：选择最近最久未使用的页面进行淘汰。
OPT（最优置换算法）：选择最远才会被再次用到的页面进行淘汰。

#### 线程池

先启动若干数量的线程，并让这些线程都处于睡眠状态，当需要申请一个线程去做具体的工作时，就会唤醒线程池中的某一个睡眠线程，让它去做具体工作，当工作完成后，线程又处于睡眠状态，而不是将线程销毁。

#### 内存池

程序预先从操作系统申请一块内存，此后，程序需要申请内存时，不是直接向操作系统申请，而是从内存池中获取；程序释放内存的时候，再返回内存池。

#### 中断与系统调用

中断就是在计算机执行程序的过程中，由于发生了某些事件，使得CPU暂停对当前程序的执行，转而去执行处理这一事件。等事件处理完之后再回去执行之前的程序。
* 内部异常中断：由计算机硬件异常或故障引起的中断
* 软中断：由程序中执行中断指令造成的中断
* 外部中断：由外部设备请求引起的中断

当程序需要使用操作系统提供的服务时，可以通过自陷指令，向操作系统发出调用服务的请求。

#### 守护进程

运行在后台的一种特殊进程，周期性地执行某些任务。

#### 僵尸进程

一个进程fork子进程，而父进程没有wait/waitpid子进程，子进程先退出，那么子进程的进程描述符仍保存在系统中。

#### 孤儿进程

一个父进程退出，而它的子进程还在运行