Retrofit不做网络请求，他的做用是按照接口去定制网络请求对象

Rtrofit使用okhttp来做网络请求，并且允许扩展okhttp，如拦截

retrofit通过converterFactory来扩展对返回数据的处理，如Gson可以解析json数据，并且如果现有的扩展无法满足，还可以通过继承retrofit.converter接口来实现自己的需求。

retrofit还通过callAdapterFactory来扩展对网络请求对象的转换，如和rxJava，协程配套，同样可以继承retrofit.callAdapter接口扩展。

Retrofit的功能是按照接口定义，自动定制Call网络工作对象，所以Retrofit的目标应该就是避免为网络访问开发大量的配套代码

为了实现这个目标，它必须分析那些是不变的那些是易变的

如网络请求是不变的，url，请求方式，请求头，返回的数据，安全方式是易变的


retrofit.create(MyAPI.class);

retrofit通常通过create方式创建一个接口实例。
create内部用了proxy的动态代理方法，主要过程都在InvocationHandler()中，它会先对方法的一些注解进行检查，然后使用method参数生成一个servermethod对象(使用loadServerMethod()它从一个ServerMethodCache中获取，如果为空，就新建)，在利用它和方法的参数生成一个okhttpcall对象。如果retrofit还扩展了calladapter，还会对call对象进行进一步扩展适配（serviceMethod.callAdapter.adapt(okHttpCall)）。

请求网络中会通过调用call对象的同步异步方法来使用okhttpclient来发起网络请求，网络响应的数据会交给parseResponse处理，它主要调用了serviceMethod.toResponse()方法，内部调用了responseConverter.convert(body)对数据进行处理然后返回。

okhttpcall是一个继承了retrofit.call的对象，内部有一个okhttp.call的引用，默认情况下指retrofit内部的okhttpclient，如果进行过扩展就指的是扩展后的okhttpclient对象。

这样做的目的retrofit与okhttp的解藕，根据依赖倒置原则。

retrofit的动态代理不同与一般的动态代理，一般使用动态代理，通常是在invok回调中执行具体接口实现类的方法进行操作。
而retrofit的动态代理起到了中转的作用，它通过接口的注解和参数生成相应的网络请求对象，在使用网络请求对象发起具体的网络请求。

在使用create方法时候，就会返回一个动态代理对象，之后调用动态代理的方法后，就会回调到create返回的动态代理中invocationhandler对象的invoke方法，然后执行相关操作，返回一个请求。

